using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
/// <summary>
/// 코드는 정확히 한 가지 일에 대해서(하나의 기능, 하나의 함수 등, 그 역할에 따라서 구분할 수 있는) 하나만 존재해야 한다. 
/// 하지만, 코딩을 하다보면, 비슷한 일을 하는 모듈이 함수의 이름만 달리하는 경우를 발견하는 경우가 종종 있다. 
/// 이러한 문제는 한 명의 개발자가 다른 개발자가 이미 작성한 코드를 이해하지 않고, 자신의 코드를 따로 만들기 떄문에 발생한다. 
/// 물론, 모든 코드를 다 이해할 수는 없다. 하지만, 남이 이미 많들어 놓았는지에 대한 검토는 필요하다. 이는 "DRY(Do not Repeat Yourself)"원칙에도 위배된다.
/// 이를 해결하기 위한 방법으로는, "이름 바꾸기(Rename Method)", "역할을 담당할 모듈로 함수 옮기기(Move Method)", "파라미터 추가(Add Parameter)"와 "함수들을 모아서 파라미터로 구부하기(Parameterize Method)"등을 사용할 수 있다. 만약, 일분의 함수 부분만 코드이 반복이 발생한다면, 해당 부분을 빼내서 새로운 함수로 만들수도 있다(Extract Superclass : 객체지향의 경우에는 해당 부분을 새로운 기반 클래스로 만들어서 해결). 대부분의 코드가 중복이 된다면, 하나의 함수를 완전히 지우고, 코드를 합치는 방법을 사용할 수도 있을 것이다.

///이렇게 함으로써 얻는 효과는 중복된 코드를 제거하기에, 공간의 절약이 있을 수 있다.또한, 코드가 중복된 의미를 생각하지 않아도 되기에, 더 읽기 귑고, 이해하기도 쉬운 코드가 된다.
///코드의 중복은 동일한 이유에 대해서 여러 수정이 존재할 가능성이 있기에, 항상 동기화시켜야 해주는 부담이 있다.따라서, 이런 부담을 제거하는 것 만으로도 코드의 버그는 줄어들 것이 분명하다. 
///모듈의 역할이 모호할 경우에도 이러한 일이 발생할 수 있기에, 모듈의 역할과 책임도 좀 더 명확해 질 수 있다.

///만약, 두 개의 모듈을 합치고자 할 때, 그 합치는 노력이 너무 크다면, 차라리 공통된 부분만을 따로 빼내서 새로운 하위 모듈로 만들고, 기존의 모듈들이 새로 만들어진 모듈을 사용하는 방식으로 처리해야할 경우도 있다. 
///이때도 마찬가지로 교집합에 해당하는 코드의 복제된 부분(역할이 복제된 것도 동일)만을 골라내야 할 것이다.즉, 각각의 모듈이 역할이 겹치는 부분을 새로운 모듈로 분리하는 경우가 이에 해당한다.

/// 기능적으로 같은 클래스
/// 공통으로 사용하는 인터페이스를 만들거나
/// 메소드 이름 변경, 이동을 수행한다.
/// </summary>

namespace RefactoringStudy._18_AlternativeClassesWithDifferentInterfaces
{
    class AlternativeClassesWithDifferentInterfaces
    {
    }
}
